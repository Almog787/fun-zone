<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Earth Destroyer - Ultimate</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; user-select: none; }
        
        /* ×××©×§ ××©×ª××© */
        #ui-container {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column; justify-content: space-between;
        }

        /* ×‘×¨ ×‘×¨×™××•×ª */
        #health-container {
            width: 100%; padding: 20px; box-sizing: border-box; text-align: center;
        }
        #health-bar-bg {
            width: 100%; max-width: 600px; height: 30px; background: rgba(50, 50, 50, 0.8);
            border: 2px solid #fff; border-radius: 15px; margin: 0 auto; overflow: hidden;
            position: relative;
        }
        #health-bar-fill {
            width: 100%; height: 100%; background: linear-gradient(90deg, #4caf50, #ffeb3b, #f44336);
            transition: width 0.2s ease-out;
        }
        #health-text {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-weight: bold; text-shadow: 1px 1px 2px black; font-size: 14px;
        }

        /* ×‘×—×™×¨×ª × ×©×§ */
        #weapon-selector {
            display: flex; justify-content: center; gap: 10px; padding: 20px;
            pointer-events: auto; background: linear-gradient(to top, rgba(0,0,0,0.9), transparent);
            flex-wrap: wrap;
        }
        .weapon-btn {
            background: rgba(0, 0, 0, 0.6); border: 2px solid #444; color: white;
            padding: 10px 20px; border-radius: 10px; cursor: pointer; font-size: 16px;
            transition: all 0.2s; backdrop-filter: blur(5px);
            display: flex; flex-direction: column; align-items: center;
        }
        .weapon-btn:active { transform: scale(0.95); }
        .weapon-btn.active { border-color: #00e5ff; background: rgba(0, 229, 255, 0.2); box-shadow: 0 0 15px #00e5ff; }
        .weapon-icon { font-size: 24px; margin-bottom: 5px; }

        /* ××¡×š ×¡×™×•× */
        #game-over {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.9); display: none;
            flex-direction: column; justify-content: center; align-items: center;
            pointer-events: auto; z-index: 100;
        }
        #game-over h1 { color: #f44336; font-size: 50px; text-transform: uppercase; margin: 0; letter-spacing: 5px; animation: pulse 2s infinite; }
        #restart-btn {
            margin-top: 30px; padding: 15px 40px; font-size: 20px;
            background: #fff; border: none; border-radius: 30px; cursor: pointer;
            font-weight: bold; text-transform: uppercase;
            box-shadow: 0 0 20px rgba(255,255,255,0.5);
        }
        
        /* ××¤×§×˜×™× */
        #flash {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: white; opacity: 0; pointer-events: none; transition: opacity 0.1s;
        }

        @keyframes pulse { 0% { opacity: 1; transform: scale(1); } 50% { opacity: 0.7; transform: scale(1.05); } 100% { opacity: 1; transform: scale(1); } }
        
        /* ×”×ª×××” ×œ× ×™×™×“ */
        @media (max-width: 600px) {
            .weapon-btn { padding: 8px 12px; font-size: 12px; }
            .weapon-icon { font-size: 18px; }
            #health-bar-bg { max-width: 90%; }
        }
    </style>
    <!-- ×˜×¢×™× ×ª Three.js ×-CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
</head>
<body>

    <div id="flash"></div>

    <div id="ui-container">
        <div id="health-container">
            <div id="health-bar-bg">
                <div id="health-bar-fill"></div>
                <span id="health-text">×©×œ××•×ª ×›×“×•×¨ ×”××¨×¥: 100%</span>
            </div>
        </div>

        <div id="weapon-selector">
            <button class="weapon-btn active" onclick="selectWeapon('asteroid')">
                <span class="weapon-icon">â˜„ï¸</span> ××¡×˜×¨×•××™×“
            </button>
            <button class="weapon-btn" onclick="selectWeapon('laser')">
                <span class="weapon-icon">âš¡</span> ×œ×™×™×–×¨
            </button>
            <button class="weapon-btn" onclick="selectWeapon('nuke')">
                <span class="weapon-icon">â˜¢ï¸</span> ×’×¨×¢×™× ×™
            </button>
            <button class="weapon-btn" onclick="selectWeapon('monster')">
                <span class="weapon-icon">ğŸ™</span> ××¤×œ×¦×ª ×—×œ×œ
            </button>
        </div>
    </div>

    <div id="game-over">
        <h1>×›×“×•×¨ ×”××¨×¥ ×”×•×©××“</h1>
        <button id="restart-btn" onclick="resetGame()">×‘× ×” ×¢×•×œ× ×—×“×©</button>
    </div>

    <script>
        // --- ×× ×•×¢ ×¡××•× ×“ (Web Audio API) ---
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioCtx = new AudioContext();

        function playSound(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);

            const now = audioCtx.currentTime;

            if (type === 'laser') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(800, now);
                osc.frequency.exponentialRampToValueAtTime(100, now + 0.3);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                osc.start(now);
                osc.stop(now + 0.3);
            } else if (type === 'explosion') {
                // ×¨×¢×© ×œ×‘×Ÿ ×œ×¤×™×¦×•×¥
                const bufferSize = audioCtx.sampleRate * 1.5;
                const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
                
                const noise = audioCtx.createBufferSource();
                noise.buffer = buffer;
                
                // ×¤×™×œ×˜×¨ × ××•×š ×œ×‘×•×
                const filter = audioCtx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 1000;
                
                noise.connect(filter);
                filter.connect(gain);
                
                gain.gain.setValueAtTime(0.5, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 1);
                
                noise.start(now);
                noise.stop(now + 1);
            } else if (type === 'monster') {
                osc.type = 'square';
                osc.frequency.setValueAtTime(50, now);
                osc.frequency.linearRampToValueAtTime(150, now + 0.5);
                gain.gain.setValueAtTime(0.2, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.8);
                osc.start(now);
                osc.stop(now + 0.8);
            }
        }

        // --- ××ª×—×•×œ Three.js ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 3.5;

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // --- ×ª××•×¨×” ---
        const ambientLight = new THREE.AmbientLight(0x333333);
        scene.add(ambientLight);
        const sunLight = new THREE.DirectionalLight(0xffffff, 1.5);
        sunLight.position.set(5, 3, 5);
        scene.add(sunLight);

        // --- ×™×¦×™×¨×ª ×›×“×•×¨ ×”××¨×¥ ---
        const textureLoader = new THREE.TextureLoader();
        // ×©×™××•×© ×‘×˜×§×¡×˜×•×¨×•×ª ×-GitHub ×›×“×™ ×œ×”×‘×˜×™×— ×–××™× ×•×ª
        const earthMap = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_atmos_2048.jpg');
        const earthBump = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_normal_2048.jpg');
        
        let earthGeometry = new THREE.SphereGeometry(1, 128, 128); // ×¨×–×•×œ×•×¦×™×” ×’×‘×•×”×” ×œ×©×™× ×•×™ ×§×¨×§×¢
        
        // ×”×•×¡×¤×ª ×¦×‘×¢×™ ×§×•×“×§×•×“×™× ×œ×©×™× ×•×™ ×¦×‘×¢ ×”×¤×™×¦×•×¥
        const count = earthGeometry.attributes.position.count;
        earthGeometry.setAttribute('color', new THREE.BufferAttribute(new Float32Array(count * 3), 3));
        
        const colors = earthGeometry.attributes.color;
        for (let i = 0; i < count; i++) {
            colors.setXYZ(i, 1, 1, 1); // ×œ×‘×Ÿ ×›×‘×¨×™×¨×ª ××—×“×œ (××©×ª××© ×‘×¦×‘×¢×™ ×”×˜×§×¡×˜×•×¨×”)
        }

        const earthMaterial = new THREE.MeshStandardMaterial({
            map: earthMap,
            normalMap: earthBump,
            roughness: 0.8,
            metalness: 0.1,
            vertexColors: true 
        });

        let earth = new THREE.Mesh(earthGeometry, earthMaterial);
        scene.add(earth);

        // --- ××˜××•×¡×¤×™×¨×” (Glow) ---
        const atmosphereGeo = new THREE.SphereGeometry(1.1, 64, 64);
        const atmosphereMat = new THREE.ShaderMaterial({
            transparent: true,
            side: THREE.BackSide,
            uniforms: {},
            vertexShader: `
                varying vec3 vNormal;
                void main() {
                    vNormal = normalize(normalMatrix * normal);
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                varying vec3 vNormal;
                void main() {
                    float intensity = pow(0.6 - dot(vNormal, vec3(0, 0, 1.0)), 4.0);
                    gl_FragColor = vec4(0.3, 0.6, 1.0, 1.0) * intensity;
                }
            `
        });
        const atmosphere = new THREE.Mesh(atmosphereGeo, atmosphereMat);
        scene.add(atmosphere);

        // --- ×›×•×›×‘×™× ×‘×¨×§×¢ ---
        const starGeo = new THREE.BufferGeometry();
        const starCount = 2000;
        const starPos = new Float32Array(starCount * 3);
        for(let i=0; i<starCount*3; i++) {
            starPos[i] = (Math.random() - 0.5) * 100;
        }
        starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
        const starMat = new THREE.PointsMaterial({color: 0xffffff, size: 0.05, transparent: true});
        const stars = new THREE.Points(starGeo, starMat);
        scene.add(stars);

        // --- ×œ×•×’×™×§×ª ××©×—×§ ---
        let currentWeapon = 'asteroid';
        let earthHealth = 100;
        let isGameOver = false;
        let shakeIntensity = 0;

        // ××™× ×˜×¨××§×¦×™×”
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        function selectWeapon(weapon) {
            currentWeapon = weapon;
            document.querySelectorAll('.weapon-btn').forEach(btn => btn.classList.remove('active'));
            event.currentTarget.classList.add('active');
        }

        window.addEventListener('pointerdown', onTouch);

        function onTouch(event) {
            if (isGameOver) return;

            // ×—×™×©×•×‘ ××™×§×•× ×¢×›×‘×¨/××’×¢
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(earth);

            if (intersects.length > 0) {
                fireWeapon(intersects[0]);
            }
        }

        function fireWeapon(impactData) {
            const point = impactData.point;
            const normal = impactData.face.normal;

            if (currentWeapon === 'asteroid') {
                createAsteroid(point);
            } else if (currentWeapon === 'laser') {
                createLaser(point);
                damageEarth(point, 5, 0.15, 0x000000); // × ×–×§ ×§×˜×Ÿ ×•×××•×§×“
            } else if (currentWeapon === 'nuke') {
                createNuke(point);
                // ×”× ×–×§ ×™×’×™×¢ ××—×¨×™ ×”×× ×™××¦×™×”
                setTimeout(() => {
                    damageEarth(point, 25, 0.4, 0x333333);
                    playSound('explosion');
                    flashScreen();
                    shakeIntensity = 0.5;
                }, 500);
            } else if (currentWeapon === 'monster') {
                createMonsterAttack(point);
                setTimeout(() => {
                    damageEarth(point, 15, 0.3, 0x330000); // × ×–×§ ××“×•× ×›×”×”
                    playSound('monster');
                    shakeIntensity = 0.3;
                }, 200);
            }
        }

        // --- ××¤×§×˜×™× ×©×œ × ×©×§×™× ---

        function createAsteroid(targetPoint) {
            const geometry = new THREE.DodecahedronGeometry(0.1, 0);
            const material = new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.9 });
            const asteroid = new THREE.Mesh(geometry, material);
            
            // ×”×ª×—×œ×” ××—×•×¥ ×œ××¡×š
            const startPos = targetPoint.clone().normalize().multiplyScalar(4);
            asteroid.position.copy(startPos);
            scene.add(asteroid);

            // ×©×•×‘×œ ××©
            const trailGeo = new THREE.BufferGeometry();
            const trailMat = new THREE.PointsMaterial({ color: 0xffaa00, size: 0.1, transparent: true, opacity: 0.8 });
            const trail = new THREE.Points(trailGeo, trailMat);
            scene.add(trail);

            // ×× ×™××¦×™×”
            const duration = 0.5;
            gsap.to(asteroid.position, {
                x: targetPoint.x, y: targetPoint.y, z: targetPoint.z,
                duration: duration,
                ease: "power1.in",
                onUpdate: () => {
                    asteroid.rotation.x += 0.1;
                    asteroid.rotation.y += 0.1;
                },
                onComplete: () => {
                    scene.remove(asteroid);
                    scene.remove(trail);
                    createExplosion(targetPoint, 0xff5500);
                    damageEarth(targetPoint, 10, 0.2, 0x222222);
                    playSound('explosion');
                    shakeIntensity = 0.2;
                }
            });
        }

        function createLaser(targetPoint) {
            const startPoint = new THREE.Vector3(targetPoint.x * 3, targetPoint.y * 3, 5); // ××§×•×¨ ×”×œ×™×™×–×¨
            const points = [startPoint, targetPoint];
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({ color: 0x00ffcc, linewidth: 5 });
            const laser = new THREE.Line(geometry, material);
            scene.add(laser);

            playSound('laser');
            createExplosion(targetPoint, 0x00ffcc, 0.5);

            setTimeout(() => scene.remove(laser), 100);
        }

        function createNuke(targetPoint) {
            // ×˜×™×œ ×§×˜×Ÿ
            const missile = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 0.2), new THREE.MeshBasicMaterial({color: 0xffffff}));
            missile.position.copy(targetPoint.clone().multiplyScalar(3));
            missile.lookAt(targetPoint);
            scene.add(missile);

            gsap.to(missile.position, {
                x: targetPoint.x, y: targetPoint.y, z: targetPoint.z,
                duration: 0.5,
                ease: "linear",
                onComplete: () => {
                    scene.remove(missile);
                    // ×¤×˜×¨×™×™×ª ×¢×©×Ÿ (×¤×©×•×˜×”)
                    createExplosion(targetPoint, 0xffaa00, 3.0);
                }
            });
        }

        function createMonsterAttack(targetPoint) {
            // ×–×¨×•×¢ ×¡×’×•×œ×” ×™×•×¦××ª ××”×›×“×•×¨
            const tentacleGeo = new THREE.ConeGeometry(0.1, 1, 8);
            const tentacleMat = new THREE.MeshStandardMaterial({ color: 0x8800ff });
            const tentacle = new THREE.Mesh(tentacleGeo, tentacleMat);
            tentacle.position.copy(targetPoint);
            tentacle.lookAt(new THREE.Vector3(0,0,0)); // ××¦×‘×™×¢ ×œ××¨×›×–
            tentacle.position.add(targetPoint.clone().normalize().multiplyScalar(0.5)); // ××–×™×– ×§×¦×ª ×”×—×•×¦×”
            scene.add(tentacle);

            gsap.to(tentacle.position, {
                x: targetPoint.x, y: targetPoint.y, z: targetPoint.z,
                duration: 0.2,
                yoyo: true,
                repeat: 1,
                onComplete: () => scene.remove(tentacle)
            });
            
            createExplosion(targetPoint, 0xaa00ff, 1.5);
        }

        function createExplosion(position, color, scale = 1.0) {
            const particleCount = 20 * scale;
            const geo = new THREE.BufferGeometry();
            const positions = [];
            
            for(let i=0; i<particleCount; i++) {
                positions.push(position.x, position.y, position.z);
            }
            geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            
            const mat = new THREE.PointsMaterial({ color: color, size: 0.1 * scale, transparent: true });
            const particles = new THREE.Points(geo, mat);
            scene.add(particles);

            const directions = [];
            for(let i=0; i<particleCount; i++) {
                directions.push(new THREE.Vector3((Math.random()-0.5), (Math.random()-0.5), (Math.random()-0.5)).normalize().multiplyScalar(0.05));
            }

            // ×× ×™××¦×™×™×ª ×—×œ×§×™×§×™× ×™×“× ×™×ª ×‘-loop
            const startTime = Date.now();
            function animateParticles() {
                const elapsed = (Date.now() - startTime) / 1000;
                if (elapsed > 1) {
                    scene.remove(particles);
                    return;
                }
                const positions = particles.geometry.attributes.position.array;
                for(let i=0; i<particleCount; i++) {
                    positions[i*3] += directions[i].x;
                    positions[i*3+1] += directions[i].y;
                    positions[i*3+2] += directions[i].z;
                }
                particles.geometry.attributes.position.needsUpdate = true;
                particles.material.opacity = 1 - elapsed;
                requestAnimationFrame(animateParticles);
            }
            animateParticles();
        }

        function flashScreen() {
            const flash = document.getElementById('flash');
            flash.style.opacity = 0.8;
            setTimeout(() => { flash.style.opacity = 0; }, 100);
        }

        // --- ×©×™× ×•×™ ×”×’×™××•××˜×¨×™×” (×”×¨×¡) ---
        function damageEarth(point, damageAmount, craterRadius, charColorHex) {
            if (isGameOver) return;

            // ×¢×“×›×•×Ÿ ×—×™×™×
            earthHealth = Math.max(0, earthHealth - damageAmount);
            updateHealthUI();

            if (earthHealth <= 0) {
                triggerGameOver();
            }

            // ×©×™× ×•×™ ×§×•×“×§×•×“×™× (××›×ª×©)
            const positions = earthGeometry.attributes.position;
            const colors = earthGeometry.attributes.color;
            const vector = new THREE.Vector3();
            const colorObj = new THREE.Color(charColorHex);

            for (let i = 0; i < positions.count; i++) {
                vector.set(positions.getX(i), positions.getY(i), positions.getZ(i));
                // ×”××¨×ª ××™×§×•× ××§×•××™ ×œ×¢×•×œ××™ ×›×“×™ ×œ×”×©×•×•×ª ×œ× ×§×•×“×ª ×”×¤×’×™×¢×” (×©×”×™× ×¢×•×œ××™×ª)
                // ×‘××§×¨×” ×”×–×”, ××›×™×•×•×Ÿ ×©×”×›×“×•×¨ ×‘-0,0,0 ×•×œ×œ× ×¨×•×˜×¦×™×” ×›×¨×’×¢ (×—×•×¥ ××”×× ×™××¦×™×”), × ×¦×˜×¨×š ×œ×”×ª×—×©×‘ ×‘×¨×•×˜×¦×™×”
                const worldPos = vector.clone().applyMatrix4(earth.matrixWorld);
                
                const dist = worldPos.distanceTo(point);

                if (dist < craterRadius) {
                    // ×”× ××›×ª ×”×’×•×‘×” (×™×¦×™×¨×ª ×‘×•×¨)
                    const pushFactor = (craterRadius - dist) * 0.5; // ×¢×•××§ ×”××›×ª×©
                    vector.multiplyScalar(1 - pushFactor); 
                    
                    positions.setXYZ(i, vector.x, vector.y, vector.z);

                    // ×¦×‘×™×¢×ª ×”××–×•×¨ ×‘×©×—×•×¨/××“×•×
                    // ×¢×¨×‘×•×‘ ×¦×‘×¢ ×§×™×™× ×¢× ×¦×‘×¢ ×”×¤×’×™×¢×”
                    colors.setXYZ(i, colorObj.r, colorObj.g, colorObj.b);
                }
            }

            earthGeometry.attributes.position.needsUpdate = true;
            earthGeometry.attributes.color.needsUpdate = true;
            earthGeometry.computeVertexNormals(); // ×¢×“×›×•×Ÿ ×ª××•×¨×”
        }

        function updateHealthUI() {
            const fill = document.getElementById('health-bar-fill');
            const text = document.getElementById('health-text');
            fill.style.width = earthHealth + '%';
            text.innerText = `×©×œ××•×ª ×›×“×•×¨ ×”××¨×¥: ${Math.round(earthHealth)}%`;
            
            // ×©×™× ×•×™ ×¦×‘×¢ ×”×‘×¨
            if(earthHealth < 30) fill.style.background = '#f44336';
            else if(earthHealth < 60) fill.style.background = '#ffeb3b';
        }

        function triggerGameOver() {
            isGameOver = true;
            playSound('explosion');
            
            // ×¤×™×¦×•×¥ ×¡×•×¤×™ ×¢× ×§
            createExplosion(new THREE.Vector3(0,0,0), 0xffaa00, 10);
            scene.remove(earth); // ×”×¢×œ××ª ×”×›×“×•×¨
            scene.remove(atmosphere);
            
            document.getElementById('game-over').style.display = 'flex';
            document.getElementById('ui-container').style.display = 'none';
        }

        // --- ××™×¤×•×¡ ××©×—×§ ---
        window.resetGame = function() {
            earthHealth = 100;
            isGameOver = false;
            updateHealthUI();
            
            // ×©×—×–×•×¨ ×›×“×•×¨ ×”××¨×¥
            scene.add(earth);
            scene.add(atmosphere);
            
            // ××™×¤×•×¡ ×’×™××•××˜×¨×™×” - ×¤×©×•×˜ ×™×•×¦×¨×™× ×—×“×© ×›×™ ×–×” ×”×›×™ × ×§×™
            const newGeo = new THREE.SphereGeometry(1, 128, 128);
            newGeo.setAttribute('color', new THREE.BufferAttribute(new Float32Array(newGeo.attributes.position.count * 3), 3));
            const cols = newGeo.attributes.color;
            for(let i=0; i<cols.count; i++) cols.setXYZ(i, 1, 1, 1);
            
            earth.geometry.dispose();
            earth.geometry = newGeo;

            document.getElementById('game-over').style.display = 'none';
            document.getElementById('ui-container').style.display = 'flex';
        };

        // --- ×œ×•×œ××ª ×× ×™××¦×™×” ×¨××©×™×ª ---
        function animate() {
            requestAnimationFrame(animate);

            // ×¡×™×‘×•×‘ ×”×›×“×•×¨ (×× ×”×•× ×§×™×™×)
            if (!isGameOver) {
                earth.rotation.y += 0.001;
                atmosphere.rotation.y += 0.001;
            }

            // ×¨×¢×™×“×•×ª
            if (shakeIntensity > 0) {
                const rx = (Math.random() - 0.5) * shakeIntensity;
                const ry = (Math.random() - 0.5) * shakeIntensity;
                const rz = (Math.random() - 0.5) * shakeIntensity;
                camera.position.set(0 + rx, 0 + ry, 3.5 + rz);
                shakeIntensity -= 0.02; // ×“×¢×™×›×”
                if (shakeIntensity < 0) {
                    shakeIntensity = 0;
                    camera.position.set(0, 0, 3.5);
                }
            }

            renderer.render(scene, camera);
        }

        // ×”×ª×××” ×œ×’×•×“×œ ××¡×š
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

    </script>
</body>
</html>
