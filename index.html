<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>מערכת מיפוי חדר פנורמי 3D</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #111; color: white; }
        canvas { display: block; }
        
        #overlay {
            position: absolute; top: 20px; right: 20px;
            background: rgba(0, 0, 0, 0.85); padding: 20px;
            border-radius: 12px; border: 1px solid #444;
            width: 280px; z-index: 100;
        }

        .section { margin-bottom: 15px; border-bottom: 1px solid #333; pb-10; }
        label { display: block; font-size: 13px; margin-bottom: 5px; color: #aaa; }
        input[type="range"] { width: 100%; cursor: pointer; }
        
        .btn {
            background: #3498db; color: white; border: none; padding: 10px;
            width: 100%; border-radius: 5px; cursor: pointer; font-weight: bold;
            margin-top: 10px; transition: 0.3s;
        }
        .btn:hover { background: #2980b9; }

        #instructions {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.6); padding: 10px 20px; border-radius: 30px;
            pointer-events: none; text-align: center; font-size: 14px;
        }

        input[type="file"] { display: none; }
        .upload-label {
            display: block; background: #2ecc71; text-align: center; padding: 10px;
            border-radius: 5px; cursor: pointer; font-weight: bold; margin-bottom: 15px;
        }
    </style>
</head>
<body>

<div id="overlay">
    <h2 style="margin-top:0; font-size: 18px;">מעבד חדר פנורמי</h2>
    
    <label class="upload-label">
        טען פנורמה מהטלפון
        <input type="file" id="imageInput" accept="image/*">
    </label>

    <div class="section">
        <label>מידות החדר (מטרים):</label>
        <label>רוחב: <span id="valW">10</span></label>
        <input type="range" id="width" min="2" max="30" step="0.1" value="10">
        
        <label>גובה: <span id="valH">3</span></label>
        <input type="range" id="height" min="2" max="10" step="0.1" value="3">
        
        <label>עומק: <span id="valD">10</span></label>
        <input type="range" id="depth" min="2" max="30" step="0.1" value="10">
    </div>

    <div class="section">
        <label>תיקון עדשה (FOV):</label>
        <input type="range" id="fov" min="40" max="120" value="75">
    </div>

    <button class="btn" onclick="requestLock()">התחל סיור בחדר</button>
</div>

<div id="instructions">
    תנועה: <b>W,A,S,D</b> | מבט: <b>עכבר</b> | יציאה: <b>ESC</b>
</div>

<script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

    let scene, camera, renderer, controls, roomMesh;
    let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
    const velocity = new THREE.Vector3();
    const direction = new THREE.Vector3();

    init();

    function init() {
        // סצנה
        scene = new THREE.Scene();
        
        // מצלמה
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1.6, 0); // גובה אדם

        // רנדרר
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // בקרת תנועה
        controls = new PointerLockControls(camera, document.body);
        
        // הגדרות חדר ראשוניות
        createRoom(10, 3, 10);

        // מאזיני אירועים
        window.addEventListener('resize', onWindowResize);
        setupControls();
        setupUI();
        animate();
    }

    function createRoom(w, h, d) {
        if (roomMesh) scene.remove(roomMesh);

        // יצירת גיאומטריה של "קופסה" הפוכה
        const geometry = new THREE.BoxGeometry(w, h, d);
        
        // שימוש ב-ShaderMaterial להקרנה פנורמית מושלמת
        // זה החלק ה"חכם" - הוא מקרין את התמונה הדו-מימדית על קואורדינטות תלת-מימדיות
        const material = new THREE.ShaderMaterial({
            uniforms: {
                panoTexture: { value: new THREE.Texture() },
                roomSize: { value: new THREE.Vector3(w, h, d) }
            },
            vertexShader: `
                varying vec3 vWorldPosition;
                void main() {
                    vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                    vWorldPosition = worldPosition.xyz;
                    gl_Position = projectionMatrix * viewMatrix * worldPosition;
                }
            `,
            fragmentShader: `
                uniform sampler2D panoTexture;
                varying vec3 vWorldPosition;
                #define PI 3.14159265359

                void main() {
                    vec3 dir = normalize(vWorldPosition);
                    float phi = atan(dir.z, dir.x);
                    float theta = acos(dir.y / length(dir));
                    
                    vec2 uv = vec2(
                        (phi + PI) / (2.0 * PI),
                        theta / PI
                    );
                    gl_FragColor = texture2D(panoTexture, uv);
                }
            `,
            side: THREE.BackSide
        });

        roomMesh = new THREE.Mesh(geometry, material);
        scene.add(roomMesh);
    }

    function setupUI() {
        const update = () => {
            const w = parseFloat(document.getElementById('width').value);
            const h = parseFloat(document.getElementById('height').value);
            const d = parseFloat(document.getElementById('depth').value);
            
            document.getElementById('valW').innerText = w;
            document.getElementById('valH').innerText = h;
            document.getElementById('valD').innerText = d;
            
            createRoom(w, h, d);
            // שמירת הטקסטורה הקיימת
            if (window.currentTexture) {
                roomMesh.material.uniforms.panoTexture.value = window.currentTexture;
            }
        };

        ['width', 'height', 'depth'].forEach(id => {
            document.getElementById(id).addEventListener('input', update);
        });

        document.getElementById('fov').addEventListener('input', (e) => {
            camera.fov = e.target.value;
            camera.updateProjectionMatrix();
        });

        document.getElementById('imageInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(event) {
                const loader = new THREE.TextureLoader();
                loader.load(event.target.result, (texture) => {
                    texture.colorSpace = THREE.SRGBColorSpace;
                    window.currentTexture = texture;
                    roomMesh.material.uniforms.panoTexture.value = texture;
                });
            };
            reader.readAsDataURL(file);
        });
    }

    function setupControls() {
        const onKeyDown = (e) => {
            switch (e.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyD': moveRight = true; break;
            }
        };
        const onKeyUp = (e) => {
            switch (e.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyD': moveRight = false; break;
            }
        };
        document.addEventListener('keydown', onKeyDown);
        document.addEventListener('keyup', onKeyUp);
    }

    window.requestLock = function() {
        controls.lock();
    };

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        requestAnimationFrame(animate);

        if (controls.isLocked) {
            const delta = 0.05;
            velocity.x -= velocity.x * 10.0 * delta;
            velocity.z -= velocity.z * 10.0 * delta;

            direction.z = Number(moveForward) - Number(moveBackward);
            direction.x = Number(moveRight) - Number(moveLeft);
            direction.normalize();

            if (moveForward || moveBackward) velocity.z -= direction.z * 400.0 * delta;
            if (moveLeft || moveRight) velocity.x -= direction.x * 400.0 * delta;

            controls.moveRight(-velocity.x * delta);
            controls.moveForward(-velocity.z * delta);
            
            // הגבלת תנועה בתוך גבולות החדר
            const w = document.getElementById('width').value / 2;
            const d = document.getElementById('depth').value / 2;
            camera.position.x = Math.max(-w + 0.5, Math.min(w - 0.5, camera.position.x));
            camera.position.z = Math.max(-d + 0.5, Math.min(d - 0.5, camera.position.z));
        }

        renderer.render(scene, camera);
    }
</script>
</body>
</html>
