<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <title>VOXEL ENGINE - OPTIMIZED</title>
    <style>
        body { margin: 0; overflow: hidden; background: #020617; font-family: 'Segoe UI', sans-serif; }
        #ui {
            position: absolute; top: 20px; left: 20px; color: #38bdf8;
            pointer-events: none; z-index: 10; background: rgba(15, 23, 42, 0.9);
            padding: 20px; border-radius: 15px; border: 1px solid #1e293b;
        }
        #controls {
            position: absolute; bottom: 30px; left: 30px; display: grid;
            grid-template-columns: 60px 60px 60px; gap: 10px; z-index: 100;
        }
        .btn {
            width: 60px; height: 60px; background: #1e293b; color: #38bdf8;
            border: 1px solid #38bdf8; border-radius: 10px; cursor: pointer;
            display: flex; justify-content: center; align-items: center; font-weight: bold;
            font-size: 20px; user-select: none; transition: 0.2s;
        }
        .btn:active { background: #38bdf8; color: #1e293b; }
        .btn-audio {
            position: absolute; top: 20px; right: 20px; background: #0ea5e9;
            color: white; border: none; padding: 15px 30px; cursor: pointer;
            border-radius: 50px; font-weight: bold; z-index: 100;
        }
    </style>
</head>
<body>

    <div id="ui">
        <h1 style="margin:0; font-size: 22px;">VOXEL ENGINE: OPTIMIZED</h1>
        <div id="status">> RENDERER: INSTANCED_MESH | STATUS: READY</div>
    </div>

    <div id="controls">
        <div></div><div class="btn" onmousedown="moveCam('up')">▲</div><div></div>
        <div class="btn" onmousedown="moveCam('left')">◀</div>
        <div class="btn" onmousedown="moveCam('down')">▼</div>
        <div class="btn" onmousedown="moveCam('right')">▶</div>
    </div>

    <button class="btn-audio" id="audioBtn" onclick="initAudio()">הפעל סאונד</button>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>

    <script>
        /** 1. מנוע סאונד **/
        let audioCtx = null;
        function initAudio() {
            if (audioCtx) return;
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            document.getElementById('audioBtn').style.display = 'none';
        }

        function playSound(type) {
            if (!audioCtx) return;
            // ... (קוד הסאונד נשאר זהה)
        }

        /** 2. אתחול מנוע **/
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x020617);
        scene.fog = new THREE.Fog(0x020617, 200, 800);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 3000);
        let camAngle = 0.8, camHeight = 120, camRadius = 300;
        
        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        scene.add(new THREE.AmbientLight(0xffffff, 0.5));
        scene.add(new THREE.DirectionalLight(0xffffff, 1).position.set(200, 500, 200));
        scene.add(new THREE.GridHelper(1500, 75, 0x1e293b, 0x0f172a));

        /** 3. בניית עיר עם INSTANCED MESH **/
        const buildings = [];
        let debris = [];
        
        // יצירת גיאומטריה וחומרים פעם אחת בלבד!
        const voxelGeo = new THREE.BoxGeometry(1.9, 1.9, 1.9);
        const materials = {
            wall: new THREE.MeshStandardMaterial({ color: 0x1e293b, roughness: 0.2, metalness: 0.5 }),
            window: new THREE.MeshStandardMaterial({ color: 0x0ea5e9, emissive: 0x0ea5e9, emissiveIntensity: 2 })
        };

        let instancedMesh;
        let totalVoxels = 0;
        let voxelIndex = 0;
        const dummy = new THREE.Object3D(); // אובייקט עזר לחישוב מיקומים
        const color = new THREE.Color(); // אובייקט עזר לחישוב צבעים

        function createCity() {
            const cityConfig = [];
            // יצירת 80 בניינים
            for (let i = 0; i < 80; i++) {
                const config = {
                    x: (Math.random() - 0.5) * 600,
                    z: (Math.random() - 0.5) * 600,
                    h: Math.floor(Math.random() * 15) + 5,
                    w: Math.floor(Math.random() * 3) + 2,
                    startVoxelIndex: voxelIndex,
                    voxelCount: 0
                };
                if (Math.abs(config.x) < 30 && Math.abs(config.z) < 30) continue;
                
                config.voxelCount = config.h * config.w * config.w;
                voxelIndex += config.voxelCount;
                totalVoxels += config.voxelCount;
                cityConfig.push(config);
            }
            
            // יצירת ה-InstancedMesh שמכיל את כל הלבנים בעיר
            instancedMesh = new THREE.InstancedMesh(voxelGeo, materials.wall, totalVoxels);
            scene.add(instancedMesh);
            
            voxelIndex = 0;
            cityConfig.forEach((config, buildingId) => {
                const building = { id: buildingId, config, destroyed: false, voxels: [] };
                for(let y=0; y<config.h; y++) {
                    for(let x=0; x<config.w; x++) {
                        for(let z=0; z<config.w; z++) {
                            const isWindow = Math.random() > 0.92;
                            dummy.position.set(config.x + x*2, y*2 + 1, config.z + z*2);
                            dummy.updateMatrix();
                            instancedMesh.setMatrixAt(voxelIndex, dummy.matrix);
                            instancedMesh.setColorAt(voxelIndex, isWindow ? color.set(0x0ea5e9) : color.set(0x1e293b));
                            
                            building.voxels.push({ index: voxelIndex, isWindow });
                            voxelIndex++;
                        }
                    }
                }
                buildings.push(building);
            });
        }
        createCity();

        /** 4. מנגנון התחדשות **/
        function scheduleRegeneration(building) {
            setTimeout(() => {
                rebuildBuilding(building);
            }, 5000 + Math.random() * 10000);
        }

        function rebuildBuilding(building) {
            building.destroyed = false;
            playSound('rebuild');

            building.voxels.forEach(voxel => {
                const config = building.config;
                const localY = Math.floor((voxel.index - config.startVoxelIndex) / (config.w * config.w));
                
                // אנימציה של המטריצה במקום האובייקט
                dummy.scale.set(0, 0, 0);
                dummy.updateMatrix();
                instancedMesh.setMatrixAt(voxel.index, dummy.matrix);

                gsap.to(dummy.scale, {
                    x: 1, y: 1, z: 1,
                    duration: 0.5,
                    delay: localY * 0.1,
                    ease: "back.out(1.7)",
                    onUpdate: () => {
                        dummy.updateMatrix();
                        instancedMesh.setMatrixAt(voxel.index, dummy.matrix);
                        instancedMesh.instanceMatrix.needsUpdate = true;
                    }
                });
            });
        }

        /** 5. שליטת מצלמה וירי **/
        function moveCam(dir) { /* ... קוד נשאר זהה ... */ }

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        window.addEventListener('mousedown', (e) => {
            if (e.target.className.includes('btn')) return;
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            
            // Raycasting ממוקד רק על ה-InstancedMesh
            const intersects = raycaster.intersectObject(instancedMesh);
            
            if (intersects.length > 0) {
                const instanceId = intersects[0].instanceId;
                // מציאת הבניין לפי ה-instanceId
                const hitBuilding = buildings.find(b => instanceId >= b.config.startVoxelIndex && instanceId < (b.config.startVoxelIndex + b.config.voxelCount));
                
                if (hitBuilding) {
                    launch(intersects[0].point, hitBuilding);
                }
            }
        });

        // Object Pooling לפגזים
        const shellPool = [];
        for (let i=0; i<5; i++) {
            const shell = new THREE.Mesh(new THREE.SphereGeometry(1.5), new THREE.MeshBasicMaterial({color: 0xffffff}));
            shell.visible = false;
            scene.add(shell);
            shellPool.push(shell);
        }
        let shellIndex = 0;

        function launch(target, building) {
            playSound('launch'); playSound('whistle');
            
            const shell = shellPool[shellIndex];
            shellIndex = (shellIndex + 1) % shellPool.length;
            
            shell.position.set(camera.position.x, camera.position.y - 20, camera.position.z);
            shell.visible = true;

            gsap.to(shell.position, {
                x: target.x, y: target.y, z: target.z,
                duration: 1.0, ease: "power2.in",
                onComplete: () => {
                    shell.visible = false; // החזרת הפגז למחסנית
                    detonate(target, building);
                }
            });
        }

        function detonate(pos, building) {
            playSound('explode');
            
            if (building && !building.destroyed) {
                building.destroyed = true;
                
                building.voxels.forEach(voxel => {
                    // "הסתרת" הווקסל מה-InstancedMesh על ידי שינוי קנה מידה
                    dummy.scale.set(0, 0, 0);
                    dummy.updateMatrix();
                    instancedMesh.setMatrixAt(voxel.index, dummy.matrix);

                    // יצירת רסיס פיזי נפרד
                    const mat = voxel.isWindow ? materials.window : materials.wall;
                    const v = new THREE.Mesh(voxelGeo, mat);
                    instancedMesh.getMatrixAt(voxel.index, dummy.matrix);
                    dummy.decompose(v.position, v.quaternion, v.scale);
                    scene.add(v);

                    const angle = Math.random() * Math.PI * 2;
                    v.userData.velocity = new THREE.Vector3(Math.cos(angle)*4, 5+Math.random()*5, Math.sin(angle)*4);
                    v.userData.active = true;
                    debris.push(v);
                });
                
                instancedMesh.instanceMatrix.needsUpdate = true;
                scheduleRegeneration(building);
            }
            // ... שאר קוד הפיצוץ ...
        }

        /** 6. אנימציה **/
        function animate() {
            requestAnimationFrame(animate);
            // ... (קוד תנועת המצלמה והפיזיקה נשאר זהה)
            renderer.render(scene, camera);
        }
        
        // ... (הקוד המלא כולל את פונקציות ה-animate, resize, וכו')
    </script>
</body>
</html>
