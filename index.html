<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <title>ULTIMATE VOXEL DESTRUCTION</title>
    <style>
        body { margin: 0; overflow: hidden; background: #020617; font-family: sans-serif; }
        #hud { position: absolute; top: 20px; left: 20px; color: #38bdf8; pointer-events: none; z-index: 10; }
        #loading { position: absolute; width: 100%; height: 100%; background: #020617; color: #38bdf8; display: flex; justify-content: center; align-items: center; z-index: 100; font-size: 24px; }
        canvas { display: block; cursor: crosshair; }
    </style>
</head>
<body>
    <div id="loading">טוען מערכות נשק ונתוני עיר...</div>
    <div id="hud">
        <h1 style="margin:0; font-size: 28px;">VOXEL ANNIHILATOR</h1>
        <p id="status">מערכת מוכנה לירי</p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>

    <script>
        let scene, camera, renderer, raycaster, mouse;
        let levelData, explosionData;
        const buildings = [];

        // טעינת נתונים
        async function start() {
            try {
                const [lRes, eRes] = await Promise.all([fetch('level.json'), fetch('explosion.json')]);
                levelData = await lRes.json();
                explosionData = await eRes.json();
                document.getElementById('loading').remove();
                init();
            } catch (e) {
                document.getElementById('loading').innerText = "שגיאה בטעינת JSON. וודא שאתה על שרת.";
            }
        }

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(levelData.environment.sky);
            scene.fog = new THREE.FogExp2(levelData.environment.sky, 0.01);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(100, 80, 150);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            const hemi = new THREE.HemisphereLight(0xffffff, 0x000000, levelData.environment.ambient);
            scene.add(hemi);

            const sun = new THREE.DirectionalLight(0xffffff, 1);
            sun.position.set(50, 100, 50);
            scene.add(sun);

            // קרקע
            const grid = new THREE.GridHelper(500, 100, levelData.environment.grid, 0x0f172a);
            scene.add(grid);

            createCity();

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            window.addEventListener('mousedown', onShoot);
            animate();
        }

        function createCity() {
            const voxelGeo = new THREE.BoxGeometry(1.9, 1.9, 1.9);
            levelData.buildings.forEach(b => {
                const group = new THREE.Group();
                const voxels = [];
                for(let y=0; y<b.h; y++) {
                    for(let x=0; x<b.w; x++) {
                        for(let z=0; z<b.d; z++) {
                            const mat = new THREE.MeshStandardMaterial({ color: b.color, metalness: 0.7 });
                            const v = new THREE.Mesh(voxelGeo, mat);
                            v.position.set(x*2 - (b.w), y*2 + 1, z*2 - (b.d));
                            group.add(v);
                            voxels.push(v);
                        }
                    }
                }
                group.position.set(b.x, 0, b.z);
                scene.add(group);
                buildings.push({ group, voxels, destroyed: false });
            });
        }

        function onShoot(e) {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(scene.children, true);
            
            if (intersects.length > 0) {
                const target = intersects[0].point;
                let hitB = buildings.find(b => b.group === intersects[0].object.parent);
                launch(target, hitB);
            }
        }

        function launch(target, building) {
            const shell = new THREE.Mesh(new THREE.SphereGeometry(1.5), new THREE.MeshBasicMaterial({color: 0xffcc00}));
            shell.position.set(150, 50, 150);
            scene.add(shell);

            gsap.to(shell.position, {
                x: target.x, z: target.z, duration: 0.8, ease: "none",
                onComplete: () => { scene.remove(shell); detonate(target, building); }
            });
            gsap.to(shell.position, { y: target.y + 50, duration: 0.4, yoyo: true, repeat: 1, ease: "power1.out" });
        }

        /** מערכת פיצוץ מורחבת **/
        function detonate(pos, building) {
            // 1. פלאש
            const flash = new THREE.PointLight(0xffaa00, explosionData.params.flashIntensity, 150);
            flash.position.copy(pos);
            scene.add(flash);
            gsap.to(flash, { intensity: 0, duration: 0.8, onComplete: () => scene.remove(flash) });

            // 2. גל הדף (Shockwave)
            const ring = new THREE.Mesh(
                new THREE.RingGeometry(1, 2, 32),
                new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.5, side: THREE.DoubleSide })
            );
            ring.position.copy(pos); ring.position.y = 0.2; ring.rotation.x = Math.PI/2;
            scene.add(ring);
            gsap.to(ring.scale, { x: explosionData.params.shockwaveRadius, y: explosionData.params.shockwaveRadius, duration: 0.6, ease: "power2.out" });
            gsap.to(ring.material, { opacity: 0, duration: 0.6, onComplete: () => scene.remove(ring) });

            // 3. חלקיקי אש ועשן
            spawnParticles(pos, explosionData.params.fireParticles, 0xff4400, 2);
            spawnParticles(pos, explosionData.params.smokeParticles, 0x333333, 4);
            spawnParticles(pos, explosionData.params.sparks, 0xffffff, 0.5);

            // 4. פירוק המבנה
            if (building && !building.destroyed) {
                building.destroyed = true;
                building.voxels.forEach((v, i) => {
                    const p = explosionData.shardPhysics[i % explosionData.shardPhysics.length];
                    const worldPos = new THREE.Vector3();
                    v.getWorldPosition(worldPos);
                    scene.attach(v);

                    gsap.to(v.position, {
                        x: worldPos.x + Math.cos(p.angle) * (p.power * 15),
                        z: worldPos.z + Math.sin(p.angle) * (p.power * 15),
                        y: worldPos.y + Math.random() * 40,
                        duration: 2, ease: "expo.out"
                    });
                    gsap.to(v.position, { y: 1, duration: 1.2, delay: 0.8, ease: "bounce.out" });
                    v.material.emissive.setHex(0xff0000);
                    gsap.to(v.material.color, { r: 0, g: 0, b: 0, duration: 3 });
                });
            }

            // 5. רעידת מצלמה
            gsap.fromTo(camera.position, { x: camera.position.x + 5 }, { x: camera.position.x, duration: 0.05, repeat: 12, yoyo: true });
        }

        function spawnParticles(pos, count, color, size) {
            for(let i=0; i<count; i++) {
                const p = new THREE.Mesh(new THREE.SphereGeometry(Math.random() * size), new THREE.MeshBasicMaterial({color, transparent: true}));
                p.position.copy(pos);
                scene.add(p);
                const v = new THREE.Vector3((Math.random()-0.5)*40, Math.random()*40, (Math.random()-0.5)*40);
                gsap.to(p.position, { x: pos.x+v.x, y: pos.y+v.y, z: pos.z+v.z, duration: 1+Math.random(), ease: "power2.out" });
                gsap.to(p.scale, { x: 0, y: 0, z: 0, duration: 1+Math.random(), onComplete: () => scene.remove(p) });
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const t = Date.now() * 0.0001;
            camera.position.x = Math.cos(t) * 160;
            camera.position.z = Math.sin(t) * 160;
            camera.lookAt(0, 0, 0);
            renderer.render(scene, camera);
        }

        start();
    </script>
</body>
</html>
