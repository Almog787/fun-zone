<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <title>VOXEL ENGINE - ORGANIC MOVEMENT</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; }
        #hud { position: absolute; top: 30px; left: 30px; color: #38bdf8; pointer-events: none; z-index: 10; }
        #loading { position: absolute; inset: 0; background: #000; color: #38bdf8; display: flex; justify-content: center; align-items: center; z-index: 100; font-size: 20px; letter-spacing: 2px; }
        .btn-audio { position: absolute; bottom: 20px; right: 20px; background: transparent; color: #38bdf8; border: 1px solid #38bdf8; padding: 10px 20px; cursor: pointer; border-radius: 5px; transition: 0.3s; }
        .btn-audio:hover { background: #38bdf8; color: #000; }
    </style>
</head>
<body>
    <div id="loading">INITIALIZING ORGANIC PHYSICS...</div>
    <div id="hud">
        <h1 style="margin:0; font-size: 28px; letter-spacing: 3px;">VOXEL COMMAND</h1>
        <p id="status">> MOTION: ORGANIC_FLOW | STATUS: ACTIVE</p>
    </div>
    <button class="btn-audio" onclick="initAudio()">ENABLE AUDIO</button>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>

    <script>
        let scene, camera, renderer, composer, raycaster, mouse, audioCtx;
        let levelData, explosionData;
        const buildings = [];
        const traffic = [];
        const debris = []; // מערך לניהול רסיסים עם פיזיקה טבעית

        function initAudio() {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            document.querySelector('.btn-audio').style.display = 'none';
        }

        function playSound(freq, type, decay) {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(1, audioCtx.currentTime + decay);
            gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + decay);
            osc.connect(gain); gain.connect(audioCtx.destination);
            osc.start(); osc.stop(audioCtx.currentTime + decay);
        }

        async function start() {
            const [lRes, eRes] = await Promise.all([fetch('level.json'), fetch('explosion.json')]);
            levelData = await lRes.json();
            explosionData = await eRes.json();
            document.getElementById('loading').remove();
            init();
        }

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(levelData.environment.sky);
            scene.fog = new THREE.FogExp2(levelData.environment.sky, 0.006);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(150, 100, 200);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            const renderScene = new THREE.RenderPass(scene, camera);
            const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), levelData.config.bloom, 0.4, 0.85);
            composer = new THREE.EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            scene.add(new THREE.AmbientLight(0xffffff, 0.4));
            const sun = new THREE.DirectionalLight(0xffffff, 1);
            sun.position.set(100, 200, 100);
            scene.add(sun);

            createCity();
            createTraffic();

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            window.addEventListener('mousemove', (e) => {
                mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            });
            window.addEventListener('mousedown', onShoot);
            animate();
        }

        function createCity() {
            scene.add(new THREE.GridHelper(1000, 80, levelData.environment.neon[0], 0x050505));
            const voxelGeo = new THREE.BoxGeometry(1.9, 1.9, 1.9);
            levelData.buildings.forEach(b => {
                const group = new THREE.Group();
                const voxels = [];
                for(let y=0; y<b.h; y++) {
                    for(let x=0; x<b.w; x++) {
                        for(let z=0; z<b.d; z++) {
                            const mat = new THREE.MeshStandardMaterial({ color: b.color, metalness: 0.8, roughness: 0.2 });
                            const v = new THREE.Mesh(voxelGeo, mat);
                            v.position.set(x*2 - (b.w), y*2 + 1, z*2 - (b.d));
                            group.add(v);
                            voxels.push(v);
                        }
                    }
                }
                group.position.set(b.x, 0, b.z);
                scene.add(group);
                buildings.push({ group, voxels, destroyed: false });
            });
        }

        function createTraffic() {
            for(let i=0; i<levelData.config.trafficCount; i++) {
                const drone = new THREE.Mesh(
                    new THREE.BoxGeometry(1.5, 0.4, 3),
                    new THREE.MeshBasicMaterial({ color: levelData.environment.neon[i % 3] })
                );
                drone.userData = { 
                    offset: Math.random() * 100, 
                    speed: 0.2 + Math.random() * 0.3,
                    radius: 50 + Math.random() * 100
                };
                scene.add(drone);
                traffic.push(drone);
            }
        }

        function onShoot() {
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(scene.children, true);
            if (intersects.length > 0) {
                const target = intersects[0].point;
                let hitB = buildings.find(b => b.group === intersects[0].object.parent);
                launch(target, hitB);
            }
        }

        function launch(target, building) {
            playSound(300, 'sine', 0.2);
            const shell = new THREE.Mesh(new THREE.SphereGeometry(1.2), new THREE.MeshBasicMaterial({color: 0xffffff}));
            shell.position.set(200, 120, 200);
            scene.add(shell);

            // תנועה בליסטית טבעית יותר עם Ease מותאם
            gsap.to(shell.position, {
                x: target.x, z: target.z, duration: 0.7, ease: "power1.inOut",
                onComplete: () => { scene.remove(shell); detonate(target, building); }
            });
            gsap.to(shell.position, { 
                y: target.y + 60, duration: 0.35, yoyo: true, repeat: 1, ease: "power2.out" 
            });
        }

        function detonate(pos, building) {
            playSound(50, 'square', 1.2);
            
            // Shockwave
            const ring = new THREE.Mesh(new THREE.RingGeometry(1, 2, 32), new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.6 }));
            ring.position.copy(pos); ring.rotation.x = -Math.PI/2;
            scene.add(ring);
            gsap.to(ring.scale, { x: 50, y: 50, duration: 1, ease: "expo.out" });
            gsap.to(ring.material, { opacity: 0, duration: 1, onComplete: () => scene.remove(ring) });

            if (building && !building.destroyed) {
                building.destroyed = true;
                building.voxels.forEach((v, i) => {
                    const worldPos = new THREE.Vector3();
                    v.getWorldPosition(worldPos);
                    scene.attach(v);
                    
                    // הוספת וקטור מהירות לרסיס (פיזיקה טבעית)
                    const angle = Math.random() * Math.PI * 2;
                    const force = 1.5 + Math.random() * 2;
                    v.userData.velocity = new THREE.Vector3(
                        Math.cos(angle) * force,
                        2 + Math.random() * 3,
                        Math.sin(angle) * force
                    );
                    v.userData.active = true;
                    debris.push(v);

                    v.material.emissive.setHex(0xff3300);
                    gsap.to(v.material.color, { r: 0, g: 0, b: 0, duration: 5 });
                });
            }

            // רעידת מצלמה "אורגנית"
            gsap.fromTo(camera.position, 
                { x: camera.position.x + 4, y: camera.position.y + 4 }, 
                { x: camera.position.x, y: camera.position.y, duration: 0.1, ease: "elastic.out(1, 0.3)" }
            );
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now() * 0.001;

            // 1. מצלמה נושמת ואורגנית
            const camOrbitRadius = 250;
            camera.position.x = Math.cos(time * 0.1) * camOrbitRadius + (mouse.x * 10);
            camera.position.z = Math.sin(time * 0.1) * camOrbitRadius + (mouse.y * 10);
            camera.position.y = 100 + Math.sin(time * 0.5) * 5; // "נשימה" אנכית
            camera.lookAt(0, 0, 0);

            // 2. תנועת רחפנים חלקה (Noise-like)
            traffic.forEach((drone, i) => {
                const d = drone.userData;
                drone.position.x = Math.cos(time * d.speed + d.offset) * d.radius;
                drone.position.z = Math.sin(time * d.speed + d.offset) * d.radius;
                drone.position.y = 30 + Math.sin(time * 2 + i) * 5; // ריחוף טבעי
                drone.rotation.y = -time * d.speed - d.offset + Math.PI/2;
            });

            // 3. פיזיקת רסיסים עם חיכוך אוויר (Air Drag)
            for (let i = debris.length - 1; i >= 0; i--) {
                const v = debris[i];
                if (v.userData.active) {
                    v.position.add(v.userData.velocity);
                    v.userData.velocity.y += levelData.config.gravity * 0.1; // כבידה
                    v.userData.velocity.multiplyScalar(levelData.config.airResistance); // חיכוך אוויר

                    if (v.position.y < 1) {
                        v.position.y = 1;
                        v.userData.velocity.set(0,0,0);
                        v.userData.active = false;
                    }
                }
            }

            composer.render();
        }

        start();
    </script>
</body>
</html>
